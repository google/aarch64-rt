// Copyright 2025 Manos Pitsidianakis <manos.pitsidianakis@linaro.org>
// This project is dual-licensed under Apache 2.0 and MIT terms.
// See LICENSE-APACHE and LICENSE-MIT for details.

type Elf64Addr = u64;
type Elf64Xword = u64;
type Elf64Sxword = i64;

const R_AARCH64_RELATIVE: u32 = 1027;

macro_rules! elf64_r_type {
    ($i:expr) => {{ (($i) & 0xffffffff) as u32 }};
}

#[derive(Copy, Clone)]
#[repr(C)]
struct Elf64Rela {
    r_offset: Elf64Addr,
    r_info: Elf64Xword,
    r_addend: Elf64Sxword,
}

unsafe extern "C" {
    static __rela_start: *mut Elf64Rela;
    static __rela_end: *mut Elf64Rela;
}

/// # Safety
///
/// This function is unsafe because it modifies executable memory.
///
/// In order for this function to work correctly, we make the following assumptions:
///
/// - `offset` argument is the actual address the binary was loaded into memory
/// - The binary uses rela relocations only (not relr)
/// - The binary must be PIE (`-pie` linker option)
/// - The binary's origin address is 0x0
///
/// Furthermore, you must also generate relocations for read-only text segments (linker option
/// `-Z notext`).
pub unsafe extern "C" fn relocate_image(offset: u64) {
    // Get __rela_start and __rela_end with assembly since .symtab header might have been stripped
    // away
    let mut rela: *mut Elf64Rela;
    let rela_end: *mut Elf64Rela;
    // SAFETY: only computes PC-relative addresses
    unsafe {
        core::arch::asm!(
            "adrp {0}, {2}",
            "add  {0}, {0}, #:lo12:{2}",
            "adrp {1}, {3}",
            "add  {1}, {1}, #:lo12:{3}",
            out(reg) rela,
            out(reg) rela_end,
            sym __rela_start,
            sym __rela_end,
        );
    }
    while rela < rela_end {
        // SAFETY: this is safe only if .rela sections have not been stripped from the binary
        let Elf64Rela {
            r_offset,
            r_info,
            r_addend,
        } = unsafe { *rela };
        if elf64_r_type!(r_info) == R_AARCH64_RELATIVE {
            // Create pointer for relocation offset with correct provenance
            // SAFETY: caller guarantees `offset` is valid, and `r_offset` is generated by the
            // linker.
            let ptr: *mut u64 = unsafe {
                rela.with_addr(offset as usize)
                    .byte_offset(r_offset as isize)
                    .cast()
            };
            // SAFETY: Safe as long as binary's ORIGIN is 0x0, otherwise r_offset will include in
            // the non-zero offset.
            unsafe { *ptr = offset + r_addend as u64 };
        }
        rela = rela.wrapping_offset(1);
    }
}
